import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import dotenv from 'dotenv';

/**
 * Cr√©e un objet de configuration bas√© sur les variables d'environnement fournies
 * @param {Object} env - L'objet contenant les variables d'environnement (par d√©faut process.env)
 * @returns {Object} - La configuration compl√®te
 */
export function createConfig(env = process.env) {
  // Valider les variables d'environnement requises
  const requiredVars = ['GOOGLE_API_KEY', 'NEYNAR_API_KEY', 'NEYNAR_SIGNER_UUID', 'BOT_HANDLE'];
  const missingVars = requiredVars.filter(varName => !env[varName]);

  if (missingVars.length > 0) {
    throw new Error(`Erreur de configuration: Les variables d'environnement suivantes sont manquantes : ${missingVars.join(', ')}`);
  }

  // Cr√©er le r√©pertoire de logs s'il n'existe pas
  const logDir = path.resolve(process.cwd(), 'logs');
  if (!fs.existsSync(logDir)) {
    try {
      fs.mkdirSync(logDir, { recursive: true });
    } catch (error) {
      console.error('Impossible de cr√©er le r√©pertoire de logs :', error);
    }
  }

  // Liste des mots-cl√©s pour la recherche d'utilisateurs
  const cryptoKeywords = [
    'blockchain', 'ethereum', 'crypto', 'defi', 'web3', 'polkadot', 'bitcoin mining'
  ];

  return {
    // Configuration des fonctionnalit√©s
    features: {
      // D√©sactiver la fonctionnalit√© de suivi d'utilisateurs
      userFollowing: false,

      // Activer les r√©ponses automatis√©es
      autoReplies: true,

      // Activer la publication programm√©e
      scheduledPosts: false
    },

    // Mots-cl√©s pour la recherche d'utilisateurs (gard√©s pour r√©f√©rence future)
    cryptoKeywords,

    // Configuration du serveur
    server: {
      port: env.PORT || 3000,
      nodeEnv: env.NODE_ENV || 'development',
      isProduction: env.NODE_ENV === 'production',
      isDevelopment: env.NODE_ENV === 'development',
    },

    // Configuration du bot
    bot: {
      handle: env.BOT_HANDLE || '@clippy',
      displayName: env.BOT_DISPLAY_NAME || 'Clippy',
      bio: env.BIO || 'ü§ñ Bot assistant Farcaster propuls√© par Gemini',
      // D√©lai entre les v√©rifications de mentions (en ms)
      mentionCheckInterval: env.MENTION_CHECK_INTERVAL
        ? parseInt(env.MENTION_CHECK_INTERVAL, 10)
        : 5 * 60 * 1000, // 5 minutes par d√©faut
    },

    // Configuration de Google Gemini
    gemini: {
      apiKey: env.GOOGLE_API_KEY,
      model: env.GEMINI_MODEL || 'gemini-2.0-flash-lite',
      temperature: parseFloat(env.GEMINI_TEMPERATURE) || 1.0,
      // Param√®tres de g√©n√©ration par d√©faut
      generationConfig: {
        temperature: 0.7,
        topP: 0.9,
        topK: 40,
        maxOutputTokens: 1024,
      },
    },

    // Configuration de Neynar
    neynar: {
      apiKey: env.NEYNAR_API_KEY,
      signerUuid: env.NEYNAR_SIGNER_UUID,
      apiUrl: env.NEYNAR_API_URL || 'https://api.neynar.com',
    },

    // Configuration de la base de donn√©es
    database: {
      client: 'sqlite3',
      connection: {
        filename: env.DATABASE_URL ?
          env.DATABASE_URL.replace('sqlite:', '') :
          './data/clippy.db',
      },
      useNullAsDefault: true,
      migrations: {
        directory: './migrations',
        tableName: 'knex_migrations',
      },
    },

    // Configuration des t√¢ches planifi√©es
    jobs: {
      // Planification des t√¢ches au format cron
      schedules: {
        dailyPost: '0 12 * * *', // Tous les jours √† midi
        checkMentions: '*/5 * * * *', // Toutes les 5 minutes
      },
      // Nombre maximum de tentatives en cas d'√©chec
      maxAttempts: 3,
      // D√©lai entre les tentatives (en ms)
      backoffMs: 5000,
      // Configuration des verrous de t√¢ches
      lock: {
        acquireTimeout: 10000, // 10 secondes
        timeout: 300000, // 5 minutes
        retries: 5,
        delay: 1000, // 1 seconde entre les tentatives
      },
    },

    // Configuration des logs
    logging: {
      // Niveau de log par d√©faut
      level: env.LOG_LEVEL || (env.NODE_ENV === 'production' ? 'info' : 'debug'),
      // R√©pertoire des fichiers de log
      directory: './logs',
      // Fichiers de log
      files: {
        error: 'error.log',
        combined: 'combined.log',
        debug: 'debug.log',
      },
      // Taille maximale des fichiers de log (en octets)
      maxSize: 10 * 1024 * 1024, // 10 Mo
      // Nombre maximum de fichiers √† conserver
      maxFiles: 5,
      // Format des dates dans les logs
      dateFormat: 'YYYY-MM-DD HH:mm:ss',
    },
  };
}

/**
 * Charge automatiquement le .env et cr√©e une configuration
 * Cette fonction est la m√©thode recommand√©e pour obtenir la config
 * @param {Object} customEnv - Variables d'environnement personnalis√©es (optionnel)
 * @returns {Object} - La configuration compl√®te
 */
export function getConfig(customEnv) {
  // Si des variables personnalis√©es sont fournies, les utiliser
  if (customEnv) {
    return createConfig(customEnv);
  }

  // Sinon, tenter de charger le .env automatiquement
  try {
    // D√©terminer le chemin du .env par rapport au fichier actuel
    const envPath = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../../.env');
    if (fs.existsSync(envPath)) {
      const envConfig = dotenv.parse(fs.readFileSync(envPath));
      return createConfig(envConfig);
    }
  } catch (error) {
    console.warn('Erreur lors du chargement automatique du .env:', error.message);
  }

  // Fallback: utiliser process.env
  return createConfig();
}

// Export par d√©faut pour compatibilit√© avec les imports existants
// ATTENTION: Ceci utilise process.env, qui peut ne pas contenir les variables
// Il est pr√©f√©rable d'utiliser getConfig() directement
export default getConfig();
